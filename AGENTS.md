# AI Agent Guide for thai-lint

**Purpose**: Primary entry point for AI agents working on this project

**Quick Start**: Read `.ai/docs/PROJECT_CONTEXT.md` for full context, then check `.ai/index.yaml` for navigation.

---

## Project Overview

The AI Linter - Lint and governance for AI-generated code across multiple languages. Identifies common mistakes, anti-patterns, and security issues in code generated by AI assistants.

**Type**: cli (Python CLI application)
**Status**: in-development

## Navigation

### Critical Documents
- **Project Context**: `.ai/docs/PROJECT_CONTEXT.md` - Architecture and philosophy
- **Index**: `.ai/index.yaml` - Repository structure and navigation
- **Layout**: `.ai/layout.yaml` - Directory organization

### How-To Guides
See `.ai/howto/` for step-by-step guides on common tasks.

### Templates
See `.ai/templates/` for reusable file templates and boilerplate.

## Roadmap-Driven Development

### When User Requests Planning

If the user says any of the following:
- "I want to plan out..."
- "I want to roadmap..."
- "Create a roadmap for..."
- "Plan the implementation of..."
- "Break down the feature..."

**Your Actions**:
1. **Read** `.ai/howtos/how-to-roadmap.md` for roadmap workflow guidance
2. **Use templates** from `.ai/templates/roadmap-*.md.template`
3. **Create roadmap** in `.roadmap/planning/[feature-name]/`
4. **Follow** the three-document structure:
   - PROGRESS_TRACKER.md (required - primary handoff document)
   - PR_BREAKDOWN.md (required for multi-PR features)
   - AI_CONTEXT.md (optional - architectural context)

### When User Requests Continuation

If the user says any of the following:
- "I want to continue with..."
- "Continue the roadmap for..."
- "What's next in..."
- "Resume work on..."

**Your Actions**:
1. **Check** `.roadmap/in-progress/` for active roadmaps
2. **Read** the roadmap's `PROGRESS_TRACKER.md` FIRST
3. **READ** `.ai/docs/FILE_HEADER_STANDARDS.md` for header templates
4. **Follow** the "Next PR to Implement" section
5. **Update** PROGRESS_TRACKER.md after completing each PR

**BEFORE Writing Any Files**:
- ‚úÖ Check `.ai/docs/FILE_HEADER_STANDARDS.md` for correct header template
- ‚úÖ Use template matching file type (Python: lines 131-151, YAML: lines 177-193, etc.)
- ‚úÖ Include ALL mandatory fields: Purpose, Scope, Overview, Dependencies, Exports, Interfaces, Implementation
- ‚úÖ Use atemporal language (no "currently", "now", "new", "old", dates, or temporal references)

### Roadmap Lifecycle

```
planning/ ‚Üí in-progress/ ‚Üí complete/
   ‚Üì             ‚Üì              ‚Üì
Created      Implementing    Archived
```

See `.ai/howtos/how-to-roadmap.md` for detailed workflow instructions.

## Development Guidelines

### Code Style
Python code follows PEP 8 style guide (enforced by Ruff linter).
- Use type hints (checked by MyPy)
- Docstrings required for all public functions (Google-style)
- **Maximum cyclomatic complexity: A** (enforced by Xenon with `--max-absolute A`)
  - This means EVERY function/method/block must be A-grade, not just averages
  - B-grade is NOT acceptable even if "it's just a helper function"

### File Organization
See `.ai/layout.yaml` for the canonical directory structure.

**Key Directories**:
- Source code: `src/`
- Tests: `tests/`
- Documentation: `docs/`

### Documentation Standards

**MANDATORY: File Headers Before Writing Any Code**

All code files MUST have comprehensive headers following `.ai/docs/FILE_HEADER_STANDARDS.md`:

**Required Process**:
1. ‚úÖ **READ** `.ai/docs/FILE_HEADER_STANDARDS.md` BEFORE writing any files
2. ‚úÖ **SELECT** correct template for file type:
   - Python (.py): Lines 131-151
   - TypeScript/JavaScript (.ts, .tsx, .js, .jsx): Lines 154-174
   - YAML/Config (.yml, .yaml): Lines 177-193
   - Markdown (.md): Lines 75-102
3. ‚úÖ **INCLUDE** all mandatory fields:
   - Purpose: Brief description (1-2 lines)
   - Scope: What areas/components this file covers
   - Overview: Comprehensive summary (3-5 sentences minimum)
   - Dependencies: Key dependencies or related files
   - Exports: Main classes, functions, or constants provided
   - Interfaces: Key APIs or methods exposed
   - Implementation: Notable patterns or architectural decisions
4. ‚úÖ **USE** atemporal language (no "currently", "now", "new", "old", dates)

**Validation**: Header linter runs in CI/CD and will block PRs with missing/incorrect headers.

See `.ai/docs/FILE_HEADER_STANDARDS.md` for complete templates and examples.

## Build and Test Commands

### Development
```bash
# Install dependencies
make install

# Run linter (fast - for development)
make lint

# Run CLI help
python -m src.cli --help
```

### Testing
```bash
# Run tests
make test

# Run tests with coverage
make test-coverage
```

### Linting
```bash
# Fast linting (Ruff only)
make lint

# Comprehensive linting (all linters + type checking)
make lint-all

# Security scanning
make lint-security

# Complexity analysis
make lint-complexity

# ALL quality checks
make lint-full
```

### Formatting
```bash
# Auto-fix formatting and linting issues
make format
```

### Building
```bash
# Build Docker container
docker compose build

# Run CLI in container
docker compose run cli --help
```

## Git Workflow

### Commit Messages
Follow conventional commits format:
```
type(scope): Brief description

Detailed description if needed.

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Branch Strategy
- `main` - Production-ready code
- `feature/*` - New features
- `fix/*` - Bug fixes

### Before Committing
- [ ] All tests pass (`make test` exits with code 0)
- [ ] Code is linted (`make lint-full` exits with code 0)
- [ ] **All files have proper headers per `.ai/docs/FILE_HEADER_STANDARDS.md`**
- [ ] Documentation updated
- [ ] No secrets committed (pre-commit hooks check this)

### Quality Gates - CRITICAL

**YOU ARE ALWAYS RESPONSIBLE FOR CODE QUALITY - NO EXCEPTIONS**

**Core Principle**: When you commit code (whether you wrote it, modified it, or just touched the same file), you are responsible for ensuring it meets ALL quality standards. There is no "not my problem" - if you're committing it, it's your responsibility.

**NEVER claim linting is clean unless ALL of these are true:**

1. ‚úÖ `make lint-full` exits with **code 0** - not 1, not 2, exactly 0
2. ‚úÖ Pylint score is **exactly 10.00/10** - not 9.98, not "close enough", exactly 10.00
3. ‚úÖ **ALL Xenon complexity checks pass** - EVERY block must be A-grade (not B, not "acceptable complexity")
4. ‚úÖ **ZERO test failures** - failing tests mean the feature is broken
5. ‚úÖ **No pre-commit hook failures** - if hooks fail, you must fix before committing

**Dangerous False Assumptions to AVOID:**

1. ‚ùå **"This was pre-existing code"**
   - If you're modifying a file, you own the quality of that file
   - If you add code to a file with issues, you must fix those issues
   - Don't rationalize "someone else wrote this" - you're committing it now

2. ‚ùå **"B-grade complexity is still good"**
   - The Makefile says `--max-absolute A` which means EVERY block must be A
   - B is NOT acceptable even if "it's just one function" or "it's a helper"
   - Don't make excuses - refactor until it's A-grade

3. ‚ùå **"9.98/10 is close enough"**
   - The requirement is 10.00/10, not "approximately 10"
   - 9.98 means there ARE violations that must be fixed
   - Don't rationalize "it's just 0.02 away" - fix it to 10.00

4. ‚ùå **"It's just a linter warning, not an error"**
   - ALL linter output must be addressed
   - Warnings are not "optional suggestions" - they must be fixed or explicitly suppressed with justification
   - Don't dismiss warnings as unimportant

5. ‚ùå **"The exit code is non-zero but the output looks okay"**
   - Exit code 0 is the ONLY acceptable result
   - Visual inspection of output is NOT a substitute for checking exit codes
   - Use `make lint-full && echo "SUCCESS" || echo "FAILED"` to verify

**Correct Validation Process:**
```bash
# Step 1: Run full linting (must exit with code 0)
make lint-full
if [ $? -ne 0 ]; then
    echo "FAILED - must fix all issues"
    exit 1
fi

# Step 2: Verify Pylint score is exactly 10.00/10
# Look for: "Your code has been rated at 10.00/10"
# NOT: 9.98/10, 9.95/10, or any other number

# Step 3: Verify Xenon shows NO errors
# Look for: No "ERROR:xenon:" lines in output
# NOT: "only B-grade" or "acceptable complexity"

# Step 4: Run tests (must exit with code 0)
make test
if [ $? -ne 0 ]; then
    echo "FAILED - must fix all tests"
    exit 1
fi

# Step 5: Only if ALL checks pass with code 0, then quality is acceptable
```

**When Standards Seem Difficult:**
- ‚úÖ DO refactor code to meet standards (extract functions, simplify logic)
- ‚úÖ DO add `# pylint: disable=rule` with detailed justification if truly necessary
- ‚úÖ DO ask the user if standards should be adjusted (but don't assume they should)
- ‚ùå DON'T lower standards on your own
- ‚ùå DON'T skip checks or claim "close enough"
- ‚ùå DON'T rationalize why violations are "acceptable"

**The Bottom Line:**
If `make lint-full` exits with non-zero code, if Pylint shows < 10.00/10, if Xenon shows ANY errors, or if tests fail - **your code is not ready to commit**. Period. No excuses, no rationalizations, no "but this was pre-existing" - fix it before committing.

## Security Considerations

- Never commit secrets or credentials
- Secrets should be in `.env` (gitignored)
- Validate user input
- Security scanning runs automatically (Bandit, Safety, Gitleaks)
- Run `make lint-security` before PRs

## Common Tasks

### Adding a New Feature
1. Check `.ai/features/` for existing feature documentation
2. Create feature branch: `git checkout -b feature/your-feature`
3. Implement feature following code style guidelines
4. Add tests in `tests/`
5. Update documentation
6. Run quality checks: `make lint-full`
7. Submit PR

### Adding a New CLI Command
See `.ai/howto/python-cli/how-to-add-cli-command.md`

### Adding a New Linter
1. Create linter module in `src/linters/`
2. Implement linter class with common interface
3. Add tests in `tests/test_linters/`
4. Register linter in CLI
5. Document linter rules

### Debugging
1. Check logs (configured in `src/cli.py`)
2. Run tests with verbose output: `pytest -v -s`
3. Use Python debugger: `python -m pdb -m src.cli`

## Resources

### Documentation
- CLI Architecture: `.ai/docs/python-cli/`
- How-to guides: `.ai/howtos/python-cli/`

### External Dependencies
See `pyproject.toml` for the complete and authoritative list of Python dependencies managed by Poetry.

## Getting Help

### When Stuck
1. Check `.ai/docs/` for context and architecture
2. Review `.ai/howto/` for guides
3. Check existing code for patterns
4. Review git history for similar changes
5. Read roadmap: `.roadmap/python-cli-install/`

### Project Roadmap
The installation is managed via roadmap at `.roadmap/python-cli-install/`:
- **PROGRESS_TRACKER.md** - Current status and next PR
- **PR_BREAKDOWN.md** - Detailed implementation steps
- **AI_CONTEXT.md** - Installation context

---

**Note**: This file is generated by ai-projen's ai-folder plugin. It will be extended by subsequent plugins (Python, Docker, CI/CD, etc.) as they are installed.

<!--
PLUGIN EXTENSION MARKERS
Plugins can add content between these markers:

### LANGUAGE_SPECIFIC_GUIDELINES
Language plugins add their specific conventions here.
### END_LANGUAGE_SPECIFIC_GUIDELINES

### INFRASTRUCTURE_COMMANDS
Infrastructure plugins add deployment/ops commands here.
### END_INFRASTRUCTURE_COMMANDS

### STANDARDS_CHECKLIST
Standards plugins add compliance checklists here.
### END_STANDARDS_CHECKLIST
-->
