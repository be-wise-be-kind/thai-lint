# AI Agent Guide for thai-lint

**Purpose**: Primary entry point for AI agents working on this project

**Quick Start**: Read `.ai/docs/PROJECT_CONTEXT.md` for full context, then check `.ai/index.yaml` for navigation.

---

## MANDATORY: First Action for Every Task

**BEFORE working on ANY task, you MUST:**

1. ‚úÖ **READ** `.ai/index.yaml` to understand available resources
2. ‚úÖ **IDENTIFY** relevant documentation, howtos, and templates for your task
3. ‚úÖ **READ** all applicable documents completely before proceeding
4. ‚úÖ **INFORM** the user which documents you are using to solve the problem

**Process:**
```
1. Scan .ai/index.yaml sections:
   - documentation: (docs for understanding)
   - howto: (step-by-step guides)
   - templates: (file templates and boilerplate)
   - standards: (requirements and best practices)

2. Read applicable documents in this order:
   - Standards/requirements first
   - How-to guides second
   - Templates third

3. Tell the user:
   "I will use these resources to solve this problem:
    - [document 1]: [why it's relevant]
    - [document 2]: [why it's relevant]"

4. Then proceed with the task following the guidance
```

**Examples:**

- **Task: Fix linting errors** ‚Üí Read `how-to-fix-linting-errors.md` and `how-to-refactor-for-quality.md`
- **Task: Write new file** ‚Üí Read `FILE_HEADER_STANDARDS.md` and `how-to-write-file-headers.md`
- **Task: Add tests** ‚Üí Read `how-to-write-tests.md`
- **Task: Create README** ‚Üí Read `readme-standards.md` and `how-to-create-readme.md`
- **Task: Plan feature** ‚Üí Read `how-to-roadmap.md` and roadmap templates

**This is NOT optional.** Skipping this step leads to incomplete work and quality issues.

---

## Project Overview

The AI Linter - Lint and governance for AI-generated code across multiple languages. Identifies common mistakes, anti-patterns, and security issues in code generated by AI assistants.

**Type**: cli (Python CLI application)
**Status**: in-development

## Navigation

### Critical Documents
- **Project Context**: `.ai/docs/PROJECT_CONTEXT.md` - Architecture and philosophy
- **Index**: `.ai/index.yaml` - Repository structure and navigation
- **Layout**: `.ai/layout.yaml` - Directory organization

### How-To Guides
See `.ai/howtos/` for step-by-step guides on common tasks.

### Templates
See `.ai/templates/` for reusable file templates and boilerplate.

## Roadmap-Driven Development

### When User Requests Planning

If the user says any of the following:
- "I want to plan out..."
- "I want to roadmap..."
- "Create a roadmap for..."
- "Plan the implementation of..."
- "Break down the feature..."

**Your Actions**:
1. **Read** `.ai/howtos/how-to-roadmap.md` for roadmap workflow guidance
2. **Use templates** from `.ai/templates/roadmap-*.md.template`
3. **Create roadmap** in `.roadmap/planning/[feature-name]/`
4. **Follow** the three-document structure:
   - PROGRESS_TRACKER.md (required - primary handoff document)
   - PR_BREAKDOWN.md (required for multi-PR features)
   - AI_CONTEXT.md (optional - architectural context)

### When User Requests Continuation

If the user says any of the following:
- "I want to continue with..."
- "Continue the roadmap for..."
- "What's next in..."
- "Resume work on..."

**Your Actions**:
1. **Check** `.roadmap/in-progress/` for active roadmaps
2. **Read** the roadmap's `PROGRESS_TRACKER.md` FIRST
3. **READ** `.ai/docs/FILE_HEADER_STANDARDS.md` for header templates
4. **Follow** the "Next PR to Implement" section
5. **Update** PROGRESS_TRACKER.md after completing each PR

**BEFORE Writing Any Files**:
- ‚úÖ Check `.ai/docs/FILE_HEADER_STANDARDS.md` for correct header template
- ‚úÖ Use template matching file type (Python: lines 131-151, YAML: lines 177-193, etc.)
- ‚úÖ Include ALL mandatory fields: Purpose, Scope, Overview, Dependencies, Exports, Interfaces, Implementation
- ‚úÖ Use atemporal language (no "currently", "now", "new", "old", dates, or temporal references)

### Roadmap Lifecycle

```
planning/ ‚Üí in-progress/ ‚Üí complete/
   ‚Üì             ‚Üì              ‚Üì
Created      Implementing    Archived
```

See `.ai/howtos/how-to-roadmap.md` for detailed workflow instructions.

## Development Guidelines

### Code Style
Python code follows PEP 8 style guide (enforced by Ruff linter).
- Use type hints (checked by MyPy)
- Docstrings required for all public functions (Google-style)
- **Maximum cyclomatic complexity: A** (enforced by Xenon with `--max-absolute A`)
  - This means EVERY function/method/block must be A-grade, not just averages
  - B-grade is NOT acceptable even if "it's just a helper function"

### File Organization
See `.ai/layout.yaml` for the canonical directory structure.

**Key Directories**:
- Source code: `src/`
- Tests: `tests/`
- Documentation: `docs/`

### Documentation Standards

**MANDATORY: File Headers Before Writing Any Code**

All code files MUST have comprehensive headers following `.ai/docs/FILE_HEADER_STANDARDS.md`:

**Required Process**:
1. ‚úÖ **READ** `.ai/docs/FILE_HEADER_STANDARDS.md` BEFORE writing any files
2. ‚úÖ **SELECT** correct template for file type:
   - Python (.py): Lines 131-151
   - TypeScript/JavaScript (.ts, .tsx, .js, .jsx): Lines 154-174
   - YAML/Config (.yml, .yaml): Lines 177-193
   - Markdown (.md): Lines 75-102
3. ‚úÖ **INCLUDE** all mandatory fields:
   - Purpose: Brief description (1-2 lines)
   - Scope: What areas/components this file covers
   - Overview: Comprehensive summary (3-5 sentences minimum)
   - Dependencies: Key dependencies or related files
   - Exports: Main classes, functions, or constants provided
   - Interfaces: Key APIs or methods exposed
   - Implementation: Notable patterns or architectural decisions
4. ‚úÖ **USE** atemporal language (no "currently", "now", "new", "old", dates)

**Validation**: Header linter runs in CI/CD and will block PRs with missing/incorrect headers.

See `.ai/docs/FILE_HEADER_STANDARDS.md` for complete templates and examples.

## Build and Test Commands

### Development
```bash
# Install dependencies
just install

# Run linter (fast - for development)
just lint

# Run CLI help
python -m src.cli --help
```

### Testing
```bash
# Run tests
just test

# Run tests with coverage
just test-coverage
```

### Linting
```bash
# Fast linting (Ruff only)
just lint

# Comprehensive linting (all linters + type checking)
just lint-all

# Security scanning
just lint-security

# Complexity analysis
just lint-complexity

# ALL quality checks
just lint-full
```

### Formatting
```bash
# Auto-fix formatting and linting issues
just format
```

### Building
```bash
# Build Docker container
docker compose build

# Run CLI in container
docker compose run cli --help
```

## Git Workflow

### Commit Messages
Follow conventional commits format:
```
type(scope): Brief description

Detailed description if needed.

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Branch Strategy
- `main` - Production-ready code
- `feature/*` - New features
- `fix/*` - Bug fixes

### Before Committing
- [ ] All tests pass (`just test` exits with code 0)
- [ ] Code is linted (`just lint-full` exits with code 0)
- [ ] **All files have proper headers per `.ai/docs/FILE_HEADER_STANDARDS.md`**
- [ ] Documentation updated
- [ ] No secrets committed (pre-commit hooks check this)

### Quality Gates - CRITICAL

**YOU ARE ALWAYS RESPONSIBLE FOR CODE QUALITY - NO EXCEPTIONS**

**Core Principle**: When you commit code (whether you wrote it, modified it, or just touched the same file), you are responsible for ensuring it meets ALL quality standards. There is no "not my problem" - if you're committing it, it's your responsibility.

**NEVER claim linting is clean unless ALL of these are true:**

1. ‚úÖ `just lint-full` exits with **code 0** - not 1, not 2, exactly 0
2. ‚úÖ Pylint score is **exactly 10.00/10** - not 9.98, not "close enough", exactly 10.00
3. ‚úÖ **ALL Xenon complexity checks pass** - EVERY block must be A-grade (not B, not "acceptable complexity")
4. ‚úÖ **ZERO test failures** - failing tests mean the feature is broken
5. ‚úÖ **No pre-commit hook failures** - if hooks fail, you must fix before committing

**Dangerous False Assumptions to AVOID:**

1. ‚ùå **"This was pre-existing code"**
   - If you're modifying a file, you own the quality of that file
   - If you add code to a file with issues, you must fix those issues
   - Don't rationalize "someone else wrote this" - you're committing it now

2. ‚ùå **"B-grade complexity is still good"**
   - The Makefile says `--max-absolute A` which means EVERY block must be A
   - B is NOT acceptable even if "it's just one function" or "it's a helper"
   - Don't make excuses - refactor until it's A-grade

3. ‚ùå **"9.98/10 is close enough"**
   - The requirement is 10.00/10, not "approximately 10"
   - 9.98 means there ARE violations that must be fixed
   - Don't rationalize "it's just 0.02 away" - fix it to 10.00

4. ‚ùå **"It's just a linter warning, not an error"**
   - ALL linter output must be addressed
   - Warnings are not "optional suggestions" - they must be fixed or explicitly suppressed with justification
   - Don't dismiss warnings as unimportant

5. ‚ùå **"The exit code is non-zero but the output looks okay"**
   - Exit code 0 is the ONLY acceptable result
   - Visual inspection of output is NOT a substitute for checking exit codes
   - Use `just lint-full && echo "SUCCESS" || echo "FAILED"` to verify

**Correct Validation Process:**
```bash
# Step 1: Run full linting (must exit with code 0)
just lint-full
if [ $? -ne 0 ]; then
    echo "FAILED - must fix all issues"
    exit 1
fi

# Step 2: Verify Pylint score is exactly 10.00/10
# Look for: "Your code has been rated at 10.00/10"
# NOT: 9.98/10, 9.95/10, or any other number

# Step 3: Verify Xenon shows NO errors
# Look for: No "ERROR:xenon:" lines in output
# NOT: "only B-grade" or "acceptable complexity"

# Step 4: Run tests (must exit with code 0)
just test
if [ $? -ne 0 ]; then
    echo "FAILED - must fix all tests"
    exit 1
fi

# Step 5: Only if ALL checks pass with code 0, then quality is acceptable
```

**When Standards Seem Difficult:**
- ‚úÖ DO refactor code to meet standards (extract functions, simplify logic)
- ‚úÖ DO ask the user for permission BEFORE adding any ignore/disable comments
- ‚úÖ DO ask the user if standards should be adjusted (but don't assume they should)
- ‚ùå DON'T add `# type: ignore`, `# pylint: disable`, `# noqa`, or similar without explicit user permission
- ‚ùå DON'T lower standards on your own
- ‚ùå DON'T skip checks or claim "close enough"
- ‚ùå DON'T rationalize why violations are "acceptable"

**CRITICAL: Suppression Comments Require User Permission**

**NEVER add linter suppression comments without explicit user permission:**
- `# type: ignore` (MyPy)
- `# pylint: disable=rule` (Pylint)
- `# noqa` (Flake8/Ruff)
- `# nosec` (Bandit)
- Any similar suppression directive

**Required Process for Suppressions:**
1. ‚úÖ **STOP** - Don't add the suppression yet
2. ‚úÖ **EXPLAIN** the problem clearly to the user
3. ‚úÖ **PROPOSE** why suppression might be needed
4. ‚úÖ **ASK** for explicit permission from the user
5. ‚úÖ **WAIT** for user approval before adding suppression
6. ‚úÖ **ADD** detailed justification comment if approved

**Good Example:**
```
"I'm encountering a MyPy error on line 260 where it doesn't understand that
node.lineno is guaranteed non-None after our validation check. I've tried:
- Using cast() with a type alias
- Creating a Protocol
- TypeGuard functions

None of these work because MyPy's AST typing is limited.

May I add `# type: ignore[assignment]` with a detailed comment explaining
the runtime validation guarantees this is safe?"
```

**Bad Example:**
```
*Just adds # type: ignore[assignment] without asking*
```

**CRITICAL: Suppression Permission is Issue-Specific and Never Transfers**

Permission to suppress one type of linting issue does NOT grant permission for other issues:

‚ùå **NEVER Transfer Permission Across:**
- **Issue types**: MyPy permission ‚â† Pylint permission ‚â† SRP permission
- **Files**: Permission for file A ‚â† permission for file B
- **Phases**: Permission in Phase 1 (basic linting) ‚â† permission in Phase 2 (refactoring)
- **Sessions**: Permission expires when context changes to a new issue category

‚úÖ **When Context Changes, Always Ask Again:**
```
Correct: "I've completed the MyPy fixes you approved. Now I found an SRP
violation in FilePlacementRule. The class has 13 methods (max 8) because
it's a framework adapter handling multiple config sources. May I suppress
this with justification?"

Wrong: "You said I could suppress things, so I'm suppressing this SRP
violation too."
```

**Examples of Scope Violations to AVOID:**

1. ‚ùå **User approves MyPy suppression ‚Üí Agent also suppresses Pylint**
   - These are different tools checking different things
   - Must ask separately for each tool

2. ‚ùå **User approves suppression in Phase 1 ‚Üí Agent suppresses in Phase 2**
   - Phase 1 (MyPy) and Phase 2 (SRP) are different categories
   - Must ask separately for each phase

3. ‚ùå **User says "if you believe it's justified" ‚Üí Agent interprets as blanket permission**
   - Conditional phrasing still requires explicit approval
   - Must demonstrate belief and ask "May I proceed?"

4. ‚ùå **User approves for file X ‚Üí Agent applies to file Y**
   - Each file requires separate evaluation
   - Must ask separately for each file

**The Permission Boundary Rule:**

Every time you encounter a NEW:
- Linter tool (MyPy vs Pylint vs Bandit vs SRP)
- File being modified
- Phase of work (Phase 1 vs Phase 2)
- Category of violation

You MUST:
1. Stop
2. Explain the new issue
3. Justify why suppression might be needed
4. Ask explicitly: "May I add suppression for THIS issue?"
5. Wait for approval

**The Bottom Line:**
If `just lint-full` exits with non-zero code, if Pylint shows < 10.00/10, if Xenon shows ANY errors, or if tests fail - **your code is not ready to commit**. Period. No excuses, no rationalizations, no "but this was pre-existing" - fix it before committing.

---

## Fixing Linting and Quality Issues

### When to Enter Systematic Linting Mode

Enter systematic linting mode when:

1. **`just lint-full` shows violations** - Any non-zero exit code requires fixing
2. **Pre-commit hooks fail** - Hooks are your first quality gate
3. **PR checks fail** - CI/CD caught issues you missed locally
4. **Working on existing code with issues** - You touched it, you own it
5. **After major refactoring** - Verify quality hasn't degraded
6. **Before creating a PR** - Always validate quality first

### The Two-Phase Approach

**CRITICAL**: Fix linting issues in TWO distinct phases. DO NOT mix them.

#### Phase 1: Basic Linting (Objective Fixes)

**Goal**: Fix mechanical, objective violations with clear right/wrong answers

**Reference**: `.ai/howtos/how-to-fix-linting-errors.md`

**Covers**:
- Code style and formatting (Ruff, Flake8)
- Security issues (Bandit, pip-audit)
- Type checking (MyPy)
- Pylint violations (docstrings, naming, etc.)

**Success Criteria**:
- `just lint` exits with code 0
- `just lint-security` exits with code 0
- MyPy shows no errors
- Pylint score is exactly 10.00/10
- All tests pass

**Process**:
```bash
# Run basic linting
just lint
just lint-security
poetry run mypy src/
poetry run pylint src/

# Fix violations following the howto guide
# Validate after each fix
just test  # Ensure nothing broke
```

#### Phase 2: Architectural Refactoring (Design Decisions)

**Goal**: Fix complexity and SRP violations through thoughtful refactoring

**Reference**: `.ai/howtos/how-to-refactor-for-quality.md`

**Covers**:
- Cyclomatic complexity (Radon, Xenon)
- Single Responsibility Principle violations (thai-lint srp)
- Nesting depth violations (thai-lint nesting)
- Architectural improvements

**Success Criteria**:
- `just lint-complexity` exits with code 0
- ALL code is A-grade (Xenon shows no errors)
- `just lint-solid` exits with code 0
- No SRP violations
- All tests pass

**Process**:
```bash
# Run architectural linting
just lint-complexity
just lint-solid

# Analyze violations together (don't fix sequentially)
# Follow decision tree in howto guide
# Refactor with both constraints in mind
just test  # Ensure nothing broke
```

### Critical Rule: Never Commit Until BOTH Phases Pass

```bash
# Final validation before commit
just lint-full   # Must exit with code 0
just test        # Must exit with code 0

# Look for:
# - Pylint: "Your code has been rated at 10.00/10"
# - Xenon: No "ERROR:xenon:" lines
# - Tests: All passed

# Only then:
git commit -m "fix: Resolve all quality issues"
```

### Common Workflow

**Scenario: You're adding a feature and linting fails**

```bash
# 1. Run full linting to assess
just lint-full > lint-output.txt 2>&1
less lint-output.txt

# 2. Phase 1: Fix basic linting
# Follow: .ai/howtos/how-to-fix-linting-errors.md
just format  # Auto-fix style
# Fix remaining issues manually
just lint
just test

# 3. Phase 2: Fix architecture (if needed)
# Follow: .ai/howtos/how-to-refactor-for-quality.md
just lint-complexity
just lint-solid
# Refactor holistically
just test

# 4. Final validation
just lint-full && just test
# Both must exit with code 0

# 5. Commit
git commit -m "feat: Add feature X with full quality compliance"
```

### The Back-and-Forth Problem

**NEVER** fix complexity and SRP sequentially:

‚ùå **Wrong Approach**:
1. Fix complexity by extracting methods
2. Run SRP linter ‚Üí now has SRP violations
3. Fix SRP by splitting classes
4. Run complexity linter ‚Üí now has complexity issues
5. Repeat endlessly

‚úÖ **Correct Approach**:
1. Analyze complexity AND SRP violations together
2. Understand WHY code is complex (multi-responsibility vs just verbose)
3. Choose refactoring strategy based on root cause
4. Refactor with BOTH constraints in mind
5. Validate both simultaneously

See `.ai/howtos/how-to-refactor-for-quality.md` for decision trees and examples.

### Integration with Existing Quality Standards

This systematic linting approach supports the Quality Gates requirements:

- **Quality Gate 1**: `just lint-full` exits with code 0
  - Achieved through Phase 1 + Phase 2 completion
- **Quality Gate 2**: Pylint score exactly 10.00/10
  - Achieved through Phase 1 (basic linting)
- **Quality Gate 3**: ALL Xenon complexity checks pass (A-grade)
  - Achieved through Phase 2 (architectural refactoring)
- **Quality Gate 4**: ZERO test failures
  - Validated after each phase
- **Quality Gate 5**: No pre-commit hook failures
  - Prevented by completing both phases before commit

### Quick Reference

| Violation Type | Phase | Howto Guide | Command |
|---------------|-------|-------------|---------|
| Style, imports, formatting | Phase 1 | how-to-fix-linting-errors.md | `just lint` |
| Security issues | Phase 1 | how-to-fix-linting-errors.md | `just lint-security` |
| Type errors | Phase 1 | how-to-fix-linting-errors.md | `poetry run mypy src/` |
| Pylint violations | Phase 1 | how-to-fix-linting-errors.md | `poetry run pylint src/` |
| Complexity (Xenon) | Phase 2 | how-to-refactor-for-quality.md | `just lint-complexity` |
| SRP violations | Phase 2 | how-to-refactor-for-quality.md | `just lint-solid` |
| Nesting depth | Phase 2 | how-to-refactor-for-quality.md | `just lint-complexity` |

---

## Security Considerations

- Never commit secrets or credentials
- Secrets should be in `.env` (gitignored)
- Validate user input
- Security scanning runs automatically (Bandit, Safety, Gitleaks)
- Run `just lint-security` before PRs

## Common Tasks

### Adding a New Feature
1. Check `.ai/features/` for existing feature documentation
2. Create feature branch: `git checkout -b feature/your-feature`
3. Implement feature following code style guidelines
4. Add tests in `tests/`
5. Update documentation
6. Run quality checks: `just lint-full`
7. Submit PR

### Adding a New CLI Command
See `.ai/howtos/python-cli/how-to-add-cli-command.md`

### Adding a New Linter
1. Create linter module in `src/linters/`
2. Implement linter class with common interface
3. Add tests in `tests/test_linters/`
4. Register linter in CLI
5. Document linter rules

### Debugging
1. Check logs (configured in `src/cli.py`)
2. Run tests with verbose output: `pytest -v -s`
3. Use Python debugger: `python -m pdb -m src.cli`

## Resources

### Documentation
- CLI Architecture: `.ai/docs/python-cli/`
- How-to guides: `.ai/howtos/python-cli/`

### External Dependencies
See `pyproject.toml` for the complete and authoritative list of Python dependencies managed by Poetry.

## Getting Help

### When Stuck
1. Check `.ai/docs/` for context and architecture
2. Review `.ai/howtos/` for guides
3. Check existing code for patterns
4. Review git history for similar changes
5. Read roadmap: `.roadmap/python-cli-install/`

### Project Roadmap
The installation is managed via roadmap at `.roadmap/python-cli-install/`:
- **PROGRESS_TRACKER.md** - Current status and next PR
- **PR_BREAKDOWN.md** - Detailed implementation steps
- **AI_CONTEXT.md** - Installation context

---

**Note**: This file is generated by ai-projen's ai-folder plugin. It will be extended by subsequent plugins (Python, Docker, CI/CD, etc.) as they are installed.

<!--
PLUGIN EXTENSION MARKERS
Plugins can add content between these markers:

### LANGUAGE_SPECIFIC_GUIDELINES
Language plugins add their specific conventions here.
### END_LANGUAGE_SPECIFIC_GUIDELINES

### INFRASTRUCTURE_COMMANDS
Infrastructure plugins add deployment/ops commands here.
### END_INFRASTRUCTURE_COMMANDS

### STANDARDS_CHECKLIST
Standards plugins add compliance checklists here.
### END_STANDARDS_CHECKLIST
-->
